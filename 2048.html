<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>2048 - ArcadeHub</title>
    <link rel="stylesheet" href="style.css">
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        /* Styles spécifiques pour 2048 */
        main {
            padding-bottom: 120px;
        }

        /* NOUVEAU : Ajout pour éviter le "tirer pour rafraîchir" sur mobile */
        body {
            overscroll-behavior: none; /* Prevents pull-to-refresh */
        }

        #game-canvas {
            touch-action: none; /* Prevents default scroll behavior on canvas */
        }
        
        .game-header {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            margin-bottom: 20px;
            font-size: 1.2rem;
            flex-wrap: wrap;
        }

        .score-box {
            background: rgba(0,0,0,0.5);
            padding: 10px 20px;
            border-radius: 5px;
            border: 2px solid var(--color-secondary-glow);
            box-shadow: 0 0 10px var(--color-secondary-glow);
        }
        .score-box p { margin: 0; }
        .score-box span { color: var(--color-tertiary-glow); }

        #game-board {
            width: 400px;
            height: 400px;
            background-color: #333;
            border: 4px solid var(--color-secondary-glow);
            box-shadow: 0 0 20px var(--color-secondary-glow);
            border-radius: 6px;
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            grid-template-rows: repeat(4, 1fr);
            gap: 10px;
            padding: 10px;
            position: relative;
        }

        .grid-cell {
            background-color: #555;
            border-radius: 3px;
        }

        .tile {
            position: absolute;
            font-family: var(--font-arcade);
            font-weight: bold;
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 3px;
            transition: all 0.15s ease-in-out;
            color: #111;
        }
        
        /* Apparition de nouvelles tuiles */
        .tile-new {
            animation: appear 0.2s ease;
        }
        @keyframes appear {
            from { transform: scale(0); }
            to { transform: scale(1); }
        }

        /* Fusion de tuiles */
        .tile-merged {
            animation: pop 0.2s ease;
        }
        @keyframes pop {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }

        /* Couleurs des tuiles */
        .tile[data-value="2"] { background-color: #eee4da; font-size: 3rem; }
        .tile[data-value="4"] { background-color: #ede0c8; font-size: 3rem; }
        .tile[data-value="8"] { background-color: #f2b179; color: #fff; font-size: 3rem; }
        .tile[data-value="16"] { background-color: #f59563; color: #fff; font-size: 2.5rem; }
        .tile[data-value="32"] { background-color: #f67c5f; color: #fff; font-size: 2.5rem; }
        .tile[data-value="64"] { background-color: #f65e3b; color: #fff; font-size: 2.5rem; }
        .tile[data-value="128"] { background-color: #edcf72; font-size: 2rem; }
        .tile[data-value="256"] { background-color: #edcc61; font-size: 2rem; }
        .tile[data-value="512"] { background-color: #edc850; font-size: 2rem; }
        .tile[data-value="1024"] { background-color: #33b1e3; color: #fff; font-size: 1.5rem; }
        .tile[data-value="2048"] { background-color: var(--color-primary-glow); color: #fff; font-size: 1.5rem; box-shadow: 0 0 20px var(--color-primary-glow); }
        .tile[data-value="4096"] { background-color: var(--color-tertiary-glow); color: #111; font-size: 1.5rem; box-shadow: 0 0 20px var(--color-tertiary-glow); }

        #game-over-screen, #win-screen { 
            position: absolute; 
            top: 0; left: 0; right: 0; bottom: 0; 
            background: rgba(0,0,0,0.85); 
            display: none; 
            flex-direction: column; 
            justify-content: center; 
            align-items: center; 
            text-align: center; 
            z-index: 100; 
            border-radius: 6px; 
        }
        #game-over-screen h2, #win-screen h2 { 
            font-family: var(--font-arcade); 
            font-size: 2.5rem; 
            margin-bottom: 20px; 
        }
        #game-over-screen h2 { 
            color: var(--color-primary-glow); 
            text-shadow: 0 0 10px var(--color-primary-glow); 
        }
        #win-screen h2 { 
            color: var(--color-tertiary-glow); 
            text-shadow: 0 0 10px var(--color-tertiary-glow); 
        }
        #game-over-screen p, #win-screen p { 
            font-family: var(--font-arcade); 
            margin: 10px 0; 
            font-size: 1.1rem; 
        }
        #game-over-screen button, #win-screen button, #start-screen button { 
            margin-top: 20px; 
            background-color: var(--color-secondary-glow); 
            color: black; 
            border: none; 
            padding: 15px 30px; 
            font-family: var(--font-arcade); 
            font-size: 1rem; 
            cursor: pointer; 
            border-radius: 5px; 
            transition: transform 0.3s; 
        }

        /* Responsive pour le plateau de jeu */
        @media (max-width: 480px) {
            #game-board {
                width: 90vw;
                height: 90vw;
                padding: 5px;
                gap: 5px;
            }
            .tile {
                font-size: 1.2rem !important; /* Force la taille pour la lisibilité */
            }
        }
        
        #start-screen { 
            position: absolute; 
            top: 0; left: 0; right: 0; bottom: 0; 
            background: rgba(0,0,0,0.7); 
            color: white; 
            font-family: 'Press Start 2P', cursive; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            text-align: center; 
            z-index: 200; 
            flex-direction: column; 
        }
        #start-screen button {
            background-color: var(--color-tertiary-glow); 
            color: black; 
            border: none; 
            padding: 15px 30px; 
            font-family: 'Press Start 2P', cursive; 
            font-size: 1.2rem; 
            cursor: pointer; 
            border-radius: 5px; 
            transition: transform 0.3s; 
            margin-top: 20px;
        }
        #start-screen button:hover {
            transform: scale(1.1);
        }
    </style>
</head>
<body>
    <button id="music-toggle-btn" title="Activer/Désactiver la musique"></button>
    <div class="background-grid"></div>
    <header>
        <h1 class="glitch" data-text="2048">2048</h1>
    </header>
    <main>
        <div class="game-header">
            <div class="score-box"><p>Score: <span id="score">0</span></p></div>
            <div class="score-box"><p>Meilleur: <span id="highscore">0</span></p></div>
        </div>
        <div class="game-container" style="border: none; box-shadow: none; background: none;">
            <div id="start-screen">
                <p>BIENVENUE SUR 2048 !</p>
                <button id="startButton">JOUER</button>
            </div>
            <div id="game-board"></div>
            <div id="game-over-screen">
                <h2 class="glitch" data-text="GAME OVER">GAME OVER</h2>
                <p>Score Final: <span id="final-score-over">0</span></p>
                <button onclick="restartGame()">REJOUER</button>
            </div>
            <div id="win-screen">
                <h2>VICTOIRE!</h2>
                <p>Vous avez atteint la tuile 2048 !</p>
                <p>Score: <span id="final-score-win">0</span></p>
                <button onclick="continueGame()">CONTINUER</button>
            </div>
        </div>
        <a href="index.html" class="back-button">&lt; RETOUR</a>
    </main>

    <script>
        // ==================================================================
        //               BLOC À COPIER-COLLER DANS CHAQUE JEU
        // ==================================================================
        const musicPlayer = new Audio('sounds/ambiance.mp3');
        musicPlayer.loop = true;
        musicPlayer.volume = 0.3;

        // Sauvegarde le temps de lecture avant de quitter la page pour une lecture fluide
        window.addEventListener('beforeunload', () => {
            if (!musicPlayer.paused) {
                localStorage.setItem('musicCurrentTime', musicPlayer.currentTime);
            }
        });

        function playSound(src, volume = 1.0) {
            const audio = new Audio(src);
            audio.volume = volume;
            audio.play();
        }

        document.addEventListener('DOMContentLoaded', () => {
            // --- Son de clic pour tous les boutons de la page ---
            const clickableElements = document.querySelectorAll('button, a.back-button');
            clickableElements.forEach(elem => {
                if (elem.id !== 'music-toggle-btn') {
                    elem.addEventListener('click', () => {
                        playSound('sounds/click.mp3');
                    });
                }
            });

            // --- Gestion du bouton de musique d'ambiance ---
            const musicBtn = document.getElementById('music-toggle-btn');
            
            const syncMusicState = () => {
                if (localStorage.getItem('musicState') === 'playing') {
                    // Récupère le temps sauvegardé pour reprendre la musique où elle s'est arrêtée
                    const savedTime = parseFloat(localStorage.getItem('musicCurrentTime') || '0');
                    musicPlayer.currentTime = savedTime;
                    musicPlayer.play().catch(e => {}); // Le catch évite les erreurs si l'autoplay est bloqué
                    musicBtn.classList.add('playing');
                } else {
                    musicPlayer.pause();
                    musicBtn.classList.remove('playing');
                }
            };
            
            musicBtn.addEventListener('click', () => {
                if (musicPlayer.paused) {
                    localStorage.setItem('musicState', 'playing');
                } else {
                    localStorage.setItem('musicState', 'paused');
                    // On supprime le temps sauvegardé quand l'utilisateur met en pause manuellement
                    localStorage.removeItem('musicCurrentTime');
                }
                syncMusicState();
            });

            syncMusicState();
        });

        const gameBoard = document.getElementById('game-board');
        const scoreElement = document.getElementById('score');
        const highscoreElement = document.getElementById('highscore');
        const gameOverScreen = document.getElementById('game-over-screen');
        const winScreen = document.getElementById('win-screen');
        const finalScoreOver = document.getElementById('final-score-over');
        const finalScoreWin = document.getElementById('final-score-win');
        const startScreen = document.getElementById('start-screen');
        const startButton = document.getElementById('startButton');
        
        const GRID_SIZE = 4;
        let grid = [];
        let score = 0;
        let highscore = localStorage.getItem('2048Highscore') || 0;
        let isGameOver = false;
        let gameStarted = false;
        let touchStartX = 0, touchStartY = 0, touchEndX = 0, touchEndY = 0;

        // Prevent pull-to-refresh during swipe
        document.addEventListener('touchstart', (e) => {
            touchStartY = e.touches[0].clientY;
        });

        document.addEventListener('touchmove', (e) => {
            if (e.touches.length === 1 && window.scrollY === 0 && e.touches[0].clientY - touchStartY > 0) {
                e.preventDefault(); /* Blocks refresh on downward swipe */
            }
        }, { passive: false });

        function init() {
            grid = Array.from({ length: GRID_SIZE }, () => Array(GRID_SIZE).fill(0));
            score = 0;
            isGameOver = false;
            
            gameOverScreen.style.display = 'none';
            winScreen.style.display = 'none';
            startScreen.style.display = 'flex';
            
            renderBoard();
            updateScores();
        }

        function startGameLogic() {
            if (gameStarted) return;
            gameStarted = true;
            startScreen.style.display = 'none';
            startGame();
        }

        // Événement pour le bouton "JOUER"
        startButton.addEventListener('click', startGameLogic);

        function startGame() {
            addRandomTile();
            addRandomTile();
            renderBoard();
            updateScores();
        }
        
        function renderBoard() {
            gameBoard.innerHTML = '';
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    const cell = document.createElement('div');
                    cell.classList.add('grid-cell');
                    gameBoard.appendChild(cell);
                    
                    if (grid[r][c] !== 0) {
                        const tile = document.createElement('div');
                        tile.classList.add('tile');
                        tile.dataset.value = grid[r][c];
                        tile.textContent = grid[r][c];
                        
                        const boardSize = gameBoard.clientWidth;
                        const CELL_GAP = 10;
                        const tileBaseSize = (boardSize - CELL_GAP * (GRID_SIZE + 1)) / GRID_SIZE;
                        tile.style.width = `${tileBaseSize}px`;
                        tile.style.height = `${tileBaseSize}px`;
                        tile.style.top = `${r * (tileBaseSize + CELL_GAP) + CELL_GAP}px`;
                        tile.style.left = `${c * (tileBaseSize + CELL_GAP) + CELL_GAP}px`;

                        gameBoard.appendChild(tile);
                    }
                }
            }
        }

        function updateScores() {
            scoreElement.textContent = score;
            highscoreElement.textContent = highscore;
            if (score > highscore) {
                highscore = score;
                localStorage.setItem('2048Highscore', highscore);
                highscoreElement.textContent = highscore;
            }
        }

        function addRandomTile() {
            const emptyCells = [];
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    if (grid[r][c] === 0) {
                        emptyCells.push({ r, c });
                    }
                }
            }
            if (emptyCells.length > 0) {
                const { r, c } = emptyCells[Math.floor(Math.random() * emptyCells.length)];
                grid[r][c] = Math.random() < 0.9 ? 2 : 4;
            }
        }
        
        function handleInput(e) {
            startGameLogic();
            if (isGameOver) return;
            let moved = false;
            switch(e.key) {
                case "ArrowUp": moved = moveUp(); break;
                case "ArrowDown": moved = moveDown(); break;
                case "ArrowLeft": moved = moveLeft(); break;
                case "ArrowRight": moved = moveRight(); break;
                default: return;
            }
            if (moved) {
                playSound('sounds/swoosh.mp3', 0.2); // <-- SON DÉPLACEMENT
                addRandomTile();
                renderBoard();
                updateScores();
                checkGameOver();
            }
        }

        // --- Move Logic ---
        function move(direction) {
            let moved = false;
            let currentGrid = JSON.parse(JSON.stringify(grid));
            
            if (direction === 'up' || direction === 'down') {
                for (let c = 0; c < GRID_SIZE; c++) {
                    let col = grid.map(row => row[c]);
                    let newCol = transformLine(col, direction === 'down');
                    if (JSON.stringify(col) !== JSON.stringify(newCol)) moved = true;
                    for(let r=0; r < GRID_SIZE; r++) grid[r][c] = newCol[r];
                }
            } else if (direction === 'left' || direction === 'right') {
                for (let r = 0; r < GRID_SIZE; r++) {
                    let row = grid[r];
                    let newRow = transformLine(row, direction === 'right');
                    if (JSON.stringify(row) !== JSON.stringify(newRow)) moved = true;
                    grid[r] = newRow;
                }
            }
            return moved;
        }

        function transformLine(line, reverse) {
            if (reverse) line.reverse();
            let newLine = line.filter(v => v !== 0);
            for (let i = 0; i < newLine.length - 1; i++) {
                if (newLine[i] === newLine[i+1]) {
                    newLine[i] *= 2;
                    score += newLine[i];
                    if(newLine[i] === 2048) showWinScreen();
                    newLine.splice(i+1, 1);
                }
            }
            while(newLine.length < GRID_SIZE) newLine.push(0);
            if (reverse) newLine.reverse();
            return newLine;
        }

        function moveUp() { return move('up'); }
        function moveDown() { return move('down'); }
        function moveLeft() { return move('left'); }
        function moveRight() { return move('right'); }

        function checkGameOver() {
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    if (grid[r][c] === 0) return;
                    if (r < GRID_SIZE - 1 && grid[r][c] === grid[r+1][c]) return;
                    if (c < GRID_SIZE - 1 && grid[r][c] === grid[r][c+1]) return;
                }
            }
            isGameOver = true;
            playSound('sounds/game-over.mp3', 0.5); // <-- SON GAME OVER
            finalScoreOver.textContent = score;
            gameOverScreen.style.display = 'flex';
        }
        
        function showWinScreen(){
            playSound('sounds/win.mp3'); // <-- SON VICTOIRE
            finalScoreWin.textContent = score;
            winScreen.style.display = 'flex';
        }

        function restartGame() {
            // Réinitialise complètement la grille et les variables
            grid = Array.from({ length: GRID_SIZE }, () => Array(GRID_SIZE).fill(0));
            score = 0;
            isGameOver = false;
            gameStarted = true; // On considère le jeu comme démarré
            
            // Cache tous les écrans de fin de partie
            gameOverScreen.style.display = 'none';
            winScreen.style.display = 'none';
            
            // Lance une nouvelle partie
            startGame();
        }

        function continueGame() {
            winScreen.style.display = 'none';
        }

        // --- Event Listeners ---
        document.addEventListener('keydown', handleInput);
        
        // Swipe listeners
        gameBoard.addEventListener('touchstart', e => {
            startGameLogic();
            touchStartX = e.changedTouches[0].clientX;
            touchStartY = e.changedTouches[0].clientY;
        }, {passive: true});

        gameBoard.addEventListener('touchend', e => {
            touchEndX = e.changedTouches[0].clientX;
            touchEndY = e.changedTouches[0].clientY;
            handleSwipe();
        });

        function handleSwipe() {
            const dx = touchEndX - touchStartX;
            const dy = touchEndY - touchStartY;
            const absDx = Math.abs(dx);
            const absDy = Math.abs(dy);

            if (Math.max(absDx, absDy) > 30) {
                let moved = false;
                if (absDx > absDy) {
                    moved = dx > 0 ? moveRight() : moveLeft();
                } else {
                    moved = dy > 0 ? moveDown() : moveUp();
                }
                if (moved) {
                    playSound('sounds/swoosh.mp3', 0.2); // <-- SON DÉPLACEMENT
                    addRandomTile();
                    renderBoard();
                    updateScores();
                    checkGameOver();
                }
            }
        }
        
        // Initial setup
        init();
        window.addEventListener('resize', renderBoard);

    </script>
</body>
</html>